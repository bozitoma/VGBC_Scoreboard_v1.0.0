"use strict";
const tslib_1 = require("tslib");
const util_1 = tslib_1.__importDefault(require("../lib/util"));
const child_process_1 = require("child_process");
const os_1 = tslib_1.__importDefault(require("os"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const fetch_tags_1 = tslib_1.__importDefault(require("../lib/fetch-tags"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const tar_1 = tslib_1.__importDefault(require("tar"));
const promises_1 = tslib_1.__importDefault(require("stream/promises"));
const NODECG_GIT_URL = 'https://github.com/nodecg/nodecg.git';
async function decideActionVersion(version, options) {
    // If NodeCG is already installed but the `-u` flag was not supplied, display an error and return.
    let isUpdate = false;
    // If NodeCG exists in the cwd, but the `-u` flag was not supplied, display an error and return.
    // If it was supplied, fetch the latest tags and set the `isUpdate` flag to true for later use.
    // Else, if this is a clean, empty directory, then we need to clone a fresh copy of NodeCG into the cwd.
    if (util_1.default.pathContainsNodeCG(process.cwd())) {
        if (!options.update) {
            console.error('NodeCG is already installed in this directory.');
            console.error('Use ' + chalk_1.default.cyan('nodecg setup [version] -u') + ' if you want update your existing install.');
            return;
        }
        isUpdate = true;
    }
    if (version) {
        process.stdout.write('Finding latest release that satisfies semver range ' + chalk_1.default.magenta(version) + '... ');
    }
    else if (isUpdate) {
        process.stdout.write('Checking against local install for updates... ');
    }
    else {
        process.stdout.write('Finding latest release... ');
    }
    let tags;
    try {
        tags = fetch_tags_1.default(NODECG_GIT_URL);
    }
    catch (e) {
        /* istanbul ignore next */
        process.stdout.write(chalk_1.default.red('failed!') + os_1.default.EOL);
        /* istanbul ignore next */
        console.error(e.stack);
        /* istanbul ignore next */
        return;
    }
    let target;
    // If a version (or semver range) was supplied, find the latest release that satisfies the range.
    // Else, make the target the newest version.
    if (version) {
        const maxSatisfying = semver_1.default.maxSatisfying(tags, version);
        if (!maxSatisfying) {
            process.stdout.write(chalk_1.default.red('failed!') + os_1.default.EOL);
            console.error('No releases match the supplied semver range (' + chalk_1.default.magenta(version) + ')');
            return;
        }
        target = maxSatisfying;
    }
    else {
        target = semver_1.default.maxSatisfying(tags, '');
    }
    process.stdout.write(chalk_1.default.green('done!') + os_1.default.EOL);
    let current;
    let downgrade = false;
    if (isUpdate) {
        current = util_1.default.getCurrentNodeCGVersion();
        if (semver_1.default.eq(target, current)) {
            console.log('The target version (%s) is equal to the current version (%s). No action will be taken.', chalk_1.default.magenta(target), chalk_1.default.magenta(current));
            return;
        }
        if (semver_1.default.lt(target, current)) {
            console.log(chalk_1.default.red('WARNING: ') + 'The target version (%s) is older than the current version (%s)', chalk_1.default.magenta(target), chalk_1.default.magenta(current));
            const answers = await inquirer_1.default.prompt([
                {
                    name: 'installOlder',
                    message: 'Are you sure you wish to continue?',
                    type: 'confirm',
                },
            ]);
            if (!answers.installOlder) {
                console.log('Setup cancelled.');
                return;
            }
            downgrade = true;
        }
    }
    if (semver_1.default.lt(target, 'v2.0.0')) {
        if (current && semver_1.default.gte(current, 'v2.0.0')) {
            console.error(`You are attempting to downgrade NodeCG from v2.x to v1.x, which is not supported.`);
            return;
        }
        await actionV1(current, target, isUpdate);
    }
    else if (semver_1.default.lt(target, 'v3.0.0')) {
        await actionV2(current, target, isUpdate);
    }
    else {
        console.error(`Unknown NodeCG verison ${chalk_1.default.magenta(version)}, perhaps you need to update nodecg-cli? (${chalk_1.default.cyan.bold('npm i -g nodecg-cli@latest')})`);
    }
    // Install NodeCG's dependencies
    // This operation takes a very long time, so we don't test it.
    if (!options.skipDependencies) {
        installDependencies();
    }
    if (isUpdate) {
        const verb = downgrade ? 'downgraded' : 'upgraded';
        console.log('NodeCG %s to', verb, chalk_1.default.magenta(target));
    }
    else {
        console.log(`NodeCG (${target}) installed to ${process.cwd()}`);
    }
}
async function actionV1(current, target, isUpdate) {
    const isGitRepo = fs_1.default.existsSync('.git');
    if (isGitRepo && isUpdate) {
        process.stdout.write('Downloading latest release...');
        try {
            child_process_1.execSync('git fetch', { stdio: ['pipe', 'pipe', 'pipe'] });
            process.stdout.write(chalk_1.default.green('done!') + os_1.default.EOL);
        }
        catch (e) {
            process.stdout.write(chalk_1.default.red('failed!') + os_1.default.EOL);
            throw e;
        }
        if (current) {
            logDownOrUpgradeMessage(current, target, semver_1.default.lt(target, current));
        }
        gitCheckoutUpdate(target);
    }
    else {
        process.stdout.write('Cloning NodeCG... ');
        try {
            child_process_1.execSync(`git clone ${NODECG_GIT_URL} .`, { stdio: ['pipe', 'pipe', 'pipe'] });
            process.stdout.write(chalk_1.default.green('done!') + os_1.default.EOL);
        }
        catch (e) {
            process.stdout.write(chalk_1.default.red('failed!') + os_1.default.EOL);
            throw e;
        }
        // Check out the target version.
        process.stdout.write(`Checking out version ${target}... `);
        try {
            child_process_1.execSync(`git checkout ${target}`, { stdio: ['pipe', 'pipe', 'pipe'] });
            process.stdout.write(chalk_1.default.green('done!') + os_1.default.EOL);
        }
        catch (e) {
            process.stdout.write(chalk_1.default.red('failed!') + os_1.default.EOL);
            throw e;
        }
    }
}
async function actionV2(current, target, isUpdate) {
    if (isUpdate) {
        const deletingDirectories = ['.git', 'build', 'scripts', 'schemas'];
        await Promise.all(deletingDirectories.map((dir) => fs_1.default.promises.rm(dir, { recursive: true, force: true })));
    }
    process.stdout.write(`Downloading ${target} from npm... `);
    const release = await util_1.default.getNodeCGRelease(target);
    process.stdout.write(chalk_1.default.green('done!') + os_1.default.EOL);
    if (current) {
        logDownOrUpgradeMessage(current, target, semver_1.default.lt(target, current));
    }
    await downloadAndExtractReleaseTarball(release.dist.tarball);
}
/* istanbul ignore next: takes forever, not worth testing */
function installDependencies() {
    try {
        process.stdout.write('Installing production npm dependencies... ');
        child_process_1.execSync('npm i --production', { stdio: ['pipe', 'pipe', 'pipe'] });
        process.stdout.write(chalk_1.default.green('done!') + os_1.default.EOL);
    }
    catch (e) {
        process.stdout.write(chalk_1.default.red('failed!') + os_1.default.EOL);
        console.error(e.stack);
        return;
    }
    if (fs_1.default.existsSync('./bower.json')) {
        process.stdout.write('Installing production bower dependencies... ');
        try {
            child_process_1.execSync('bower install --production', { stdio: ['pipe', 'pipe', 'pipe'] });
            process.stdout.write(chalk_1.default.green('done!') + os_1.default.EOL);
        }
        catch (e) {
            process.stdout.write(chalk_1.default.red('failed!') + os_1.default.EOL);
            console.error(e.stack);
        }
    }
}
function gitCheckoutUpdate(target) {
    try {
        child_process_1.execSync(`git checkout ${target}`, { stdio: ['pipe', 'pipe', 'pipe'] });
        process.stdout.write(chalk_1.default.green('done!') + os_1.default.EOL);
    }
    catch (e) {
        /* istanbul ignore next */
        process.stdout.write(chalk_1.default.red('failed!') + os_1.default.EOL);
        /* istanbul ignore next */
        console.error(e.stack);
    }
}
async function downloadAndExtractReleaseTarball(tarballUrl) {
    const res = await node_fetch_1.default(tarballUrl);
    if (!res.body) {
        throw new Error(`Failed to fetch release tarball from ${tarballUrl}, status code ${res.status}`);
    }
    await promises_1.default.pipeline(res.body, tar_1.default.x({ strip: 1 }));
}
function logDownOrUpgradeMessage(current, target, downgrade) {
    const Verb = downgrade ? 'Downgrading' : 'Upgrading';
    process.stdout.write(Verb + ' from ' + chalk_1.default.magenta(current) + ' to ' + chalk_1.default.magenta(target) + '... ');
}
module.exports = function (program) {
    program
        .command('setup [version]')
        .option('-u, --update', 'Update the local NodeCG installation')
        .option('-k, --skip-dependencies', 'Skip installing npm & bower dependencies')
        .description('Install a new NodeCG instance')
        .action(decideActionVersion);
};
