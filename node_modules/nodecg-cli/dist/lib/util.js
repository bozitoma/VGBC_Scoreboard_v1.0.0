"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const semver_1 = tslib_1.__importDefault(require("semver"));
exports.default = {
    /**
     * Checks if the given directory contains a NodeCG installation.
     * @param pathToCheck
     */
    pathContainsNodeCG(pathToCheck) {
        const pjsonPath = path_1.default.join(pathToCheck, 'package.json');
        if (fs_1.default.existsSync(pjsonPath)) {
            const pjson = require(pjsonPath);
            return pjson.name.toLowerCase() === 'nodecg';
        }
        return false;
    },
    /**
     * Gets the nearest NodeCG installation folder. First looks in process.cwd(), then looks
     * in every parent folder until reaching the root. Throws an error if no NodeCG installation
     * could be found.
     */
    getNodeCGPath() {
        let curr = process.cwd();
        do {
            if (this.pathContainsNodeCG(curr)) {
                return curr;
            }
            const nextCurr = path_1.default.resolve(curr, '..');
            if (nextCurr === curr) {
                throw new Error('NodeCG installation could not be found in this directory or any parent directory.');
            }
            curr = nextCurr;
        } while (fs_1.default.lstatSync(curr).isDirectory());
        throw new Error('NodeCG installation could not be found in this directory or any parent directory.');
    },
    /**
     * Checks if the given directory is a NodeCG bundle.
     */
    isBundleFolder(pathToCheck) {
        const pjsonPath = path_1.default.join(pathToCheck, 'package.json');
        if (fs_1.default.existsSync(pjsonPath)) {
            const pjson = require(pjsonPath);
            return typeof pjson.nodecg === 'object';
        }
        return false;
    },
    /**
     * Gets the currently-installed NodeCG version string, in the format "vX.Y.Z"
     */
    getCurrentNodeCGVersion() {
        const nodecgPath = this.getNodeCGPath();
        return JSON.parse(fs_1.default.readFileSync(`${nodecgPath}/package.json`, 'utf8')).version;
    },
    /**
     * Gets the latest NodeCG release information from npm, including tarball download link.
     */
    async getNodeCGRelease(target) {
        var _a;
        const targetVersion = (_a = semver_1.default.coerce(target)) === null || _a === void 0 ? void 0 : _a.version;
        if (!targetVersion) {
            throw new Error(`Failed to determine target NodeCG version`);
        }
        const res = await node_fetch_1.default(`http://registry.npmjs.org/nodecg/${targetVersion}`);
        if (res.status !== 200) {
            throw new Error(`Failed to fetch NodeCG release information from npm, status code ${res.status}`);
        }
        return res.json();
    },
    async getLatestCLIRelease() {
        const res = await node_fetch_1.default('http://registry.npmjs.org/nodecg-cli/latest');
        if (res.status !== 200) {
            throw new Error(`Failed to fetch NodeCG release information from npm, status code ${res.status}`);
        }
        return res.json();
    },
};
